# C. Shifted MEX

**时间限制**：每测试点 2 秒
**内存限制**：每测试点 256 MB
**link**: https://codeforces.com/contest/2185/problem/C

---

## 题目描述

给你一个由 `n` 个整数组成的数组 `a₁, a₂, …, aₙ`。你被允许执行以下操作**一次**：
* 选择一个整数 `x`（可以是负数），并将数组中的每个元素 `aᵢ` 替换为 `aᵢ + x`。

例如，如果 `a = [1, 3, 4, 2]`，且执行操作 `x = 3`，则数组将变为 `[4, 6, 7, 5]`。

在**执行完操作后**，输出数组 **MEX(a)** 可能达到的**最大值**。

**MEX(a)** 定义为**不在**数组中的最小**非负**整数。
* 例如，`MEX([1, 2, 0, 5]) = 3`（因为 `0, 1, 2` 存在，但 `3` 不存在）。
* `MEX([1, 2, 4, 9]) = 0`。
* `MEX([0, 1, 2]) = 3`。

---

## 输入格式

输入的第一行包含一个整数 `t` (`1 ≤ t ≤ 1000`) —— 测试用例的数量。

每个测试用例的描述如下：
* 第一行包含一个整数 `n` (`1 ≤ n ≤ 3000`) —— 数组 `a` 的长度。
* 第二行包含 `n` 个整数 `a₁, a₂, …, aₙ` (`-10⁹ ≤ aᵢ ≤ 10⁹`) —— 数组 `a`。

**保证**所有测试用例的 `n` 之和不超过 `3000`。

---

## 输出格式

对于每个测试用例，输出在执行操作后，数组 `MEX(a)` 可能达到的最大值。

---

## 样例

### 输入
```
6
1
4
5
0 1 1 2 3
2
1 1
4
2 3 6 4
5
2 4 1 0 -1
6
-1 1 2 3 5 6
```
### 输出
```
1
4
1
3
3
4
```

---

## 样例解释

**对于第一个测试用例**：
执行操作 `x = -4`，使数组变为 `[0]`，此时 `MEX([0]) = 1`。

**对于第二个测试用例**：
初始数组为 `[0, 1, 1, 2, 3]`，包含 `0, 1, 2, 3`。最小的未出现非负整数是 `4`。这已经是可能的最大值，因此可以执行 `x = 0` 的操作（不改变数组）。

---

## 补充说明与算法思路

### 核心观察
* 操作 `x` 会将整个数组的所有元素平移相同的值。
* 目标是平移后，数组的 **MEX** 尽可能大。

### 关键思路
由于可以自由选择平移量 `x`，问题等价于：
> 选择一个目标起始非负整数 `target`（希望 `target, target+1, target+2, ...` 这个序列能尽量长地出现在平移后的数组中），计算最多能连续覆盖到哪个整数。

更具体地说，假设我们希望通过平移，让数组包含 `0, 1, 2, ..., k-1`（即 `MEX = k`）。这要求原始数组中，**存在**一些数，使得：
`a[i] + x = 0` (某个数变成0)
`a[j] + x = 1` (某个数变成1)
...
`a[?] + x = k-1` (某个数变成k-1)

这等价于：原始数组中，必须能找到 `k` 个**互不相同**的数，使得它们与 `0, 1, ..., k-1` 的差值（即 `(target - a[i])`）**全部相同**（这个相同的差值就是 `x`）。

### 高效算法（O(n²) 或 O(n log n)）
1.  **排序去重**：首先处理数组 `a`，获取其所有**互不相同的**值，并排序。设去重后的数组为 `vals`，长度为 `m`。
2.  **枚举起点**：由于最终 MEX 对应的连续整数序列 `0, 1, 2, ..., ans-1` 在平移后出现，其起点 `base`（即平移后值为 `0` 的那个原始数）必然是 `vals` 中的某个元素（或者是其他值，但最优解一定可以由 `vals` 中某元素作为起点达到）。
3.  **贪心匹配**：对于每个可能的起点 `vals[i]`，计算平移量 `x = -vals[i]`。然后检查：
    将整个数组平移 `x` 后，从 `0` 开始，最长能连续覆盖到哪个整数（即 MEX-1）。
    这可以通过检查 `vals` 中是否存在 `vals[i]`, `vals[i]+1`, `vals[i]+2`, ... 来实现。因为数组已排序，可以使用双指针快速计算以 `vals[i]` 为起点的最长连续“可用数字”的长度。
4.  **取最大值**：对所有 `i` 计算出的最长连续长度取最大值，这个最大值就是 `MEX` 的可能最大值（因为长度为 `L` 的连续覆盖意味着 `MEX` 至少为 `L`，而 `L` 就是 MEX 值）。
5.  **注意边界**：由于我们总是希望覆盖从 `0` 开始的序列，但原始数组经过平移 `x` 后，`0` 对应的原始值是 `-x`。因此，在算法中，我们实际上是枚举一个“基准值”，使得平移后这个基准值变为 `0`，然后看从这个基准值开始，在原始数组中能向上连续找到多少个数（差值为1）。这个连续长度就是平移后从 `0` 开始的连续非负整数长度，即 MEX。

### 复杂度分析
* 排序去重：`O(n log n)`。
* 枚举起点 `O(m)`，每个起点用双指针扫描 `O(m)`，总 `O(m²)`。由于 `n ≤ 3000`，`m` 更小，完全可接受。
* 整体复杂度对题目限制非常安全。

### 简单结论
对于给定的数组，答案最大不会超过 `n + 1`（因为最多能覆盖 `0` 到 `n` 共 `n+1` 个数，此时 MEX = n+1）。通过上述枚举，可以高效找到确切的最大 MEX。